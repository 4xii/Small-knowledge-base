HTTP网络层 
代码编译层webpack
代码运行层html css js vue react
安全xss csrf

## url解析
http://user:pass@www.xxx.com.cn:80/index.html?lx=1&from=wx#video
http 协议

user:pass 登录信息

www.xxx.com.cn 域名：服务器地址

80 端口号: 0~65535 服务器端177.34.14.131上 端口80项目一 端口81项目2
默认端口号: HTTP 80  /  HTTPS443  / FTP  21

index.html 请求资源文件路径

lx=1&from=wx 查询字符串:问号参数
```js
let url = "http://www.xxx.cn/api/?lx=1&name=世新&from=http://www.baidu.com";
//编码处理
//对整个URL的编码：处理空格/处理空格
//encodeURI/decodeURI

//主要对传递的参数信息进行编码
//encodeURIComponent / decodeURIComponent
let url1 = `http://www.xxx.cn/api/?lx=1&name=${encodeURIComponent("世新")}&from=${encodeURIComponent("http://www.baidu.com")}`;
```


#video 片段标识符：HASH值

HTTPS：SLL/TLS
FTP传输一些大文件

# 缓存检测(静态资源缓存)
1.先检查是否存在强缓存
+ 有 且未生效，走强缓存
+ 如果没有，或者失效
  检测是否有协商缓存
  +有
  +没用 重新获取数据

缓存位置：内存缓存  硬盘缓存
强缓存cache-contorl
携带标识向本地请求 -> 本地没有再向服务器发送新http请求 ->返回请求结果缓存标识

* 服务器更新后，让资源名称和之前不一样，这样页面导入全新的资源 webpack name
* 当文件更新后，在html导入的时候，设置一个后缀（时间戳）
```html
<script src="index.js?325116><script>
```

协商缓存 强缓存失效 Last-Modified/ETag
携带缓存标识发送HTTP请求
[没更新] 304，读取缓存           [更新过] 200 并且更新资源
304 从本地缓存中获取内容进        200 直接渲染 并且缓存

如果协商缓存没用（没用传任何标识）
服务器收到请求准备内容 
Last-Modified 资源文件最后更新时间 
ETag记录一个标识，资源文件更新生成的，每一次都会重新生成ETag

第二次发送请求
客户端拿到信息后渲染，信息和标识都缓存到本地
if(Modified-since = Last-Modified if-None_Mach = ETag)
给服务器
服务器判断文件是否更新

# DNS
本地 -> DNS服务器
减少DNS请求（一个页面尽量减少不同域名：资源放在相同服务器）但是真实项目会把不同资源放在不同服务器上 web服务器 数据服务器 影音服务器 图片服务器
资源合理应用

# TCP三次握手
建立连接通道 建立完成之后 不关闭 connection:keep-alive
# TCP四次挥手
释放TCP通道

HTTP1.0 每次请求建立TCP，用完关闭
HTTP1.1 长连接 若干个请求排队串行化单线程处理，后面的请求等待前面的返回才能获得执行机会，一旦请求超时，后面的都会被阻塞（线头阻塞）
HTTP2.0 可以同时发送多个请求 多路复用


## 状态码
2XX 请求成功
2XX 的响应结果表明请求被正常处理了。200表示请求在服务器端被正常处理了。在响应报文内，随状态码一起返回的信息会因方法的不同而发生改变。//204表示服务器接收的请求已经成功处理，但是在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。当浏览器在发送请求后接收到204响应，它的显示页面不会发生更新。
206表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文内包含由Content-Range指定范围的实体内容。

3XX 重定向
3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。
301 永久重定向，301状态码表示请求的资源已经分配了新的URI，以后请求该资源应该访问新的URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。
302临时重定向，302表示请求的资源已经被分配了新的URI，希望客户端本次能使用新的URI访问。和301不同的是，这种资源的URI变更是临时的额，而不是永久的，因此不用去更新书签。
303 See Other
该状态码和 302 有着异曲同工之妙，表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。
如果浏览器原本是用POST方法去请求服务器，收到303状态码之后，会改用GET并访问资源新的URI。
304 状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。例如，客户端请求的资源在客户端本地已有缓存，会在请求头部中加入“If-Modified-Since", "If-None-Match"等字段，服务端根据这些字段信息判断这些资源信息是否经过修改，如果没有则返回 304 状态码，客户端可以直接使用缓存中的资源。

304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。
PS：附带条件的请求是指采用GET方法的请求报文中包含If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since中任一首部。
307 Temporary Redirect
临时重定向，和 302 Found 状态码有相同的含义。区别在于 307 不会强制浏览器将 POST 方法改为 GET 方法，而是遵循浏览器自身的标准。

4XX 客户端错误
4XX 的响应结果表明客户端是发生错误的原因所在。
400 Bad Request
400 状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。
401 Unauthorized
401 状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。第一次收到 401 状态码表示需要进行用户认证，第二次再收到 401 状态码说明用户认证失败。
403 Forbidden
403 状态码表明对请求资源的访问被服务器拒绝了，当未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能发生 403 。
404 Not Found
404 是我们最常见的状态码之一，它表示服务器上无法找到请求资源。此外，也可能是服务器端在拒绝请求且不想说明原因的时候使用。

5XX 服务器错误
5XX 的响应结果表明服务器本身发生错误。
500 Internal Server Error
500 状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。
503 Service Unavailable
503 状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求

## HTTPS与HTTP区别
1.安全性上，HTTPS是安全超文本协议，在HTTP基础上有更强的安全性。简单来说，HTTPS是使用TLS/SSL加密的HTTP协议 
2.申请证书上，HTTPS需要使用ca申请证书 
3.传输协议上, HTTP是超文本传输协议，明文传输；HTTPS是具有安全性的 SSL 加密传输协议 
4.连接方式与端口上，http的连接简单，是无状态的，端口是 80； https 在http的基础上使用了ssl协议进行加密传输，端口是 443